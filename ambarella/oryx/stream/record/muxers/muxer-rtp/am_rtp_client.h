/*******************************************************************************
 * am_rtp_client.h
 *
 * History:
 *   2015-1-6 - [ypchang] created file
 *
 * Copyright (c) 2016 Ambarella, Inc.
 *
 * This file and its contents ("Software") are protected by intellectual
 * property rights including, without limitation, U.S. and/or foreign
 * copyrights. This Software is also the confidential and proprietary
 * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
 * disclose, distribute, modify, or otherwise prepare derivative works of this
 * Software or any portion thereof except pursuant to a signed license agreement
 * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
 * In the absence of such an agreement, you agree to promptly notify and return
 * this Software to Ambarella, Inc.
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
 * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************/
#ifndef ORYX_STREAM_RECORD_MUXERS_MUXER_RTP_AM_RTP_CLIENT_H_
#define ORYX_STREAM_RECORD_MUXERS_MUXER_RTP_AM_RTP_CLIENT_H_

#include "am_rtp_msg.h"
#include "am_mutex.h"
#include "rtp.h"
#include "rtcp.h"

#include <atomic>

enum AM_CLIENT_CMD
{
  AM_CLIENT_CMD_ABORT = 'a',
  AM_CLIENT_CMD_STOP  = 's',
  AM_CLIENT_CMD_ACK   = 'k',
};

enum AM_NET_STATE
{
  AM_NET_OK,
  AM_NET_ERROR,
  AM_NET_AGAIN,
  AM_NET_SLOW,
  AM_NET_PEER_SHUTDOWN,
  AM_NET_BADFD,
};

struct RtpClientConfig;
struct AMRtpClientData
{
    uint32_t        ssrc;        /* generated by RTP session */
    uint32_t        session_id;  /* client identifier        */
    int             proto_fd;    /* protocol server's RTP fd */
    int             tcp_fd;      /* shared with RTSP server  */
    int             udp_fd_rtp;  /* created by RTP session   */
    int             udp_fd_rtcp; /* created by RTP session   */
    std::string     name;
    AMRtpClientInfo client;
    AMRtpClientData(int proto_fd, int fd_tcp,
                    uint32_t session, const AMRtpClientInfo &info);
    ~AMRtpClientData();
    bool init(RtpClientConfig &config);
    int setup_udp_socket(RtpClientConfig &config, uint16_t port);
    struct sockaddr* client_rtp_address(socklen_t *addr_len);
    struct sockaddr* client_rtcp_address(socklen_t *addr_len);
    uint16_t client_rtp_port();
    uint16_t client_rtcp_port();
};

struct RtcpRRPacket
{
    AMRtcpHeader    rtcp_common_head;
    AMRtcpRRPayload rtcp_rr_payload[];
    uint32_t sender_ssrc();
};

struct RtcpSRPacket
{
  AMRtcpHeader rtcp_common_head;
  AMRtcpSRPayload rtcp_sr_payload;
  AMRtcpRRPayload rtcp_rr_payload[];
  uint32_t sender_ssrc();
};

struct RtcpSRBuffer
{
    AMRtpTcpHeader  tcp_hdr;
    AMRtcpHeader    rtcp_hdr;
    AMRtcpSRPayload rtcp_sr;
};

class AMEvent;
class AMThread;
class AMMuxerRtp;
class AMRtpSession;
class AMIRtpSession;
class AMRtpClientConfig;

class AMRtpClient
{
    friend class AMMuxerRtp;
    friend class AMRtpSession;

  public:
    static AMRtpClient* create(const std::string &config,
                               int proto_fd,
                               int tcp_fd,
                               int ctrl_fd,
                               uint32_t session,
                               AMMuxerRtp *muxer,
                               const AMRtpClientInfo &clientInfo);

  public:
    bool start();
    void stop();
    void set_enable(bool enable);
    bool is_alive();
    bool is_abort();
    bool is_enable();
    bool is_new_client();
    void set_new_client(bool new_client);
    void destroy(bool send_notify = true);
    uint32_t ssrc();
    void inc_ref();
    void set_session(AMIRtpSession *session);

  protected:
    AMRtpClient(int ctrl_fd, AMMuxerRtp *muxer);
    virtual ~AMRtpClient();
    bool init(const std::string &config,
              int proto_fd,
              int tcp_fd,
              uint32_t session,
              const AMRtpClientInfo &clientInfo);

  private:
    static void static_rtcp_monitor(void *data);
    static void static_packet_sender(void *data);
    void rtcp_monitor();
    void packet_sender();
    AM_NET_STATE tcp_send(int fd, uint8_t *data, uint32_t len);
    AM_NET_STATE udp_send(int fd, sockaddr *addr, uint8_t *data, uint32_t len);
    AM_NET_STATE send_rtcp_packet(uint8_t *data, uint32_t len);
    void update_rtcp_sr_pkt_num_bytes(RtcpSRBuffer &sr,
                                      uint32_t pkt_num,
                                      uint32_t payload_size);
    void build_rtcp_sr_packet(RtcpSRBuffer &sr,
                              uint32_t ssrc,
                              uint32_t rtp_ts,
                              uint64_t ntp_ts);
    void abort_client(bool send_cmd);
    void send_ack();
    bool send_kill_client();
    bool send_thread_cmd(AM_CLIENT_CMD cmd);

  private:
    uint64_t           m_start_clock_90k = 0ULL;
    uint64_t           m_tcp_max_speed   = 0ULL;
    uint64_t           m_tcp_min_speed   = ((uint64_t)-1);
    uint64_t           m_tcp_avg_speed   = 0ULL;
    uint64_t           m_udp_max_speed   = 0ULL;
    uint64_t           m_udp_min_speed   = ((uint64_t)-1);
    uint64_t           m_udp_avg_speed   = 0ULL;
    uint64_t           m_tcp_send_time   = 0ULL;
    uint64_t           m_udp_send_time   = 0ULL;
    uint64_t           m_tcp_send_size   = 0ULL;
    uint64_t           m_udp_send_size   = 0ULL;
    RtpClientConfig   *m_client_config   = nullptr; /* No need to delete */
    AMRtpClientConfig *m_config          = nullptr;
    AMRtpClientData   *m_client          = nullptr;
    AMThread          *m_rtcp_monitor    = nullptr;
    AMThread          *m_packet_sender   = nullptr;
    AMEvent           *m_rtp_event       = nullptr;
    AMEvent           *m_rtcp_event      = nullptr;
    AMMuxerRtp        *m_muxer           = nullptr;
    RtcpSRBuffer      *m_rtcp_sr_buf     = nullptr;
    AMRtcpHeader      *m_rtcp_hdr        = nullptr;
    AMRtcpSRPayload   *m_rtcp_sr         = nullptr;
    AMIRtpSession     *m_session         = nullptr;
    uint32_t           m_tcp_send_count  = 0;
    uint32_t           m_udp_send_count  = 0;
    int                m_ctrl_fd         = -1;
    int                m_ctrl[2]         = {-1};
    std::atomic<bool>  m_run             = {true};
    std::atomic<bool>  m_is_new          = {true};
    std::atomic<bool>  m_abort           = {false};
    std::atomic<bool>  m_enable          = {false};
    std::atomic<int>   m_ref_count       = {0};
    AMMemLock          m_lock;
#define RTP_CLI_R      m_ctrl[0]
#define RTP_CLI_W      m_ctrl[1]
};

#endif /* ORYX_STREAM_RECORD_MUXERS_MUXER_RTP_AM_RTP_CLIENT_H_ */
